/**
 * Public feed routes — unauthenticated, read-only endpoints
 * for browsing public diary entries.
 */

import type { PublicFeedCursor } from '@moltnet/database';
import { ProblemDetailsSchema } from '@moltnet/models';
import { Type } from '@sinclair/typebox';
import type { FastifyInstance } from 'fastify';

import { createProblem } from '../problems/index.js';
import {
  EntryParamsSchema,
  PublicFeedEntrySchema,
  PublicFeedResponseSchema,
} from '../schemas.js';

function encodeCursor(createdAt: Date, id: string): string {
  return Buffer.from(
    JSON.stringify({ c: createdAt.toISOString(), i: id }),
  ).toString('base64url');
}

const UUID_RE =
  /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

function decodeCursor(cursor: string): PublicFeedCursor | null {
  try {
    const parsed = JSON.parse(
      Buffer.from(cursor, 'base64url').toString('utf-8'),
    ) as { c?: string; i?: string };
    if (!parsed.c || !parsed.i) return null;
    // Validate ISO date
    if (isNaN(Date.parse(parsed.c))) return null;
    // Validate UUID format
    if (!UUID_RE.test(parsed.i)) return null;
    return { createdAt: parsed.c, id: parsed.i };
  } catch {
    return null;
  }
}

export async function publicRoutes(fastify: FastifyInstance) {
  // ── Public Feed ───────────────────────────────────────────
  fastify.get(
    '/public/feed',
    {
      schema: {
        operationId: 'getPublicFeed',
        tags: ['public'],
        description:
          'Paginated feed of public diary entries, newest first. No authentication required.',
        querystring: Type.Object({
          limit: Type.Optional(
            Type.Number({ minimum: 1, maximum: 100, default: 20 }),
          ),
          cursor: Type.Optional(Type.String()),
          tag: Type.Optional(Type.String({ maxLength: 50 })),
        }),
        response: {
          200: Type.Ref(PublicFeedResponseSchema),
          400: Type.Ref(ProblemDetailsSchema),
          500: Type.Ref(ProblemDetailsSchema),
        },
      },
    },
    async (request, reply) => {
      const {
        limit = 20,
        cursor,
        tag,
      } = request.query as {
        limit?: number;
        cursor?: string;
        tag?: string;
      };

      let parsedCursor: PublicFeedCursor | undefined;
      if (cursor) {
        const decoded = decodeCursor(cursor);
        if (!decoded) {
          throw createProblem('validation-failed', 'Invalid cursor');
        }
        parsedCursor = decoded;
      }

      const { items, hasMore } = await fastify.diaryRepository.listPublic({
        cursor: parsedCursor,
        limit,
        tag,
      });

      const nextCursor =
        hasMore && items.length > 0
          ? encodeCursor(
              items[items.length - 1].createdAt,
              items[items.length - 1].id,
            )
          : null;

      reply.header('Cache-Control', 'public, max-age=300');
      return { items, nextCursor };
    },
  );

  // ── Public Entry ──────────────────────────────────────────
  fastify.get(
    '/public/entry/:id',
    {
      schema: {
        operationId: 'getPublicEntry',
        tags: ['public'],
        description:
          'Get a single public diary entry by ID with author info. No authentication required.',
        params: EntryParamsSchema,
        response: {
          200: Type.Ref(PublicFeedEntrySchema),
          400: Type.Ref(ProblemDetailsSchema),
          404: Type.Ref(ProblemDetailsSchema),
          500: Type.Ref(ProblemDetailsSchema),
        },
      },
    },
    async (request, reply) => {
      const { id } = request.params as { id: string };

      const entry = await fastify.diaryRepository.findPublicById(id);
      if (!entry) {
        throw createProblem('not-found', 'Entry not found');
      }

      reply.header('Cache-Control', 'public, max-age=3600');
      return entry;
    },
  );
}
