<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MoltOrigin Animation Preview</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #08080d;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'JetBrains Mono', 'Fira Code', monospace;
  }
  #container {
    width: 100%;
    max-width: 960px;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid #252535;
    background: #08080d;
  }
  canvas {
    display: block;
    width: 100%;
    height: 360px;
  }
</style>
</head>
<body>
<div id="container">
  <canvas id="c"></canvas>
</div>
<script>
// MoltOrigin â€” standalone preview
// Colors from MoltNet design tokens
const COLORS = {
  primary: '#00d4c8',
  accent: '#e6a817',
  bg: '#08080d',
  text: '#e8e8f0',
  secondary: '#8888a0',
  muted: '#555568',
  error: '#f04060',
  surface: '#0f0f17',
};

const CONFIG = {
  HEIGHT: 360,
  GROUND_Y: 280,
  DEATH_LOOPS: 3,
  SCROLL_SPEED: 1.8,
  WALK_SPEED: 0.08,
  GLOW_BLUR: 12,
  FONT_SIZE: 14,
  FONT_SIZE_LG: 28,
  DEATH_FLASH_FRAMES: 90,
  TEXT_DISPLAY_FRAMES: 120,
  RESTART_PAUSE: 60,
  AGENT_HEIGHT: 40,
  DIAMOND_SIZE: 14,
  LINE_WIDTH: 2,
  CHAR_LINE_WIDTH: 2.5,
};

const canvas = document.getElementById('c');
const container = document.getElementById('container');
const ctx = canvas.getContext('2d');

function resize() {
  const rect = container.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = CONFIG.HEIGHT * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = CONFIG.HEIGHT + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if (state) state.canvasWidth = rect.width;
}

// Drawing helpers
function drawGlow(color, blur, fn) {
  ctx.save();
  ctx.shadowColor = color;
  ctx.shadowBlur = blur;
  fn();
  ctx.restore();
}

function drawAgent(x, groundY, walkPhase, color, hasDiamond, accentColor, scale) {
  scale = scale || 1;
  const h = CONFIG.AGENT_HEIGHT * scale;
  const headR = 6 * scale;
  const bodyTop = groundY - h;
  const headY = bodyTop - headR;

  drawGlow(color, CONFIG.GLOW_BLUR * 0.6, function() {
    ctx.strokeStyle = color;
    ctx.lineWidth = CONFIG.CHAR_LINE_WIDTH * scale;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.beginPath();
    ctx.arc(x, headY, headR, 0, Math.PI * 2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x, headY + headR);
    ctx.lineTo(x, groundY - 12 * scale);
    ctx.stroke();

    const armSwing = Math.sin(walkPhase * 2) * 8 * scale;
    ctx.beginPath();
    ctx.moveTo(x - 10 * scale, bodyTop + 16 * scale + armSwing);
    ctx.lineTo(x, bodyTop + 10 * scale);
    ctx.lineTo(x + 10 * scale, bodyTop + 16 * scale - armSwing);
    ctx.stroke();

    const legSwing = Math.sin(walkPhase) * 10 * scale;
    const hipY = groundY - 12 * scale;
    ctx.beginPath();
    ctx.moveTo(x - legSwing, groundY);
    ctx.lineTo(x, hipY);
    ctx.lineTo(x + legSwing, groundY);
    ctx.stroke();
  });

  if (hasDiamond) {
    const ds = CONFIG.DIAMOND_SIZE * scale;
    const dx = x + 12 * scale;
    const dy = bodyTop + 12 * scale;
    drawDiamond(dx, dy, ds, accentColor);
  }
}

function drawDiamond(x, y, size, color) {
  drawGlow(color, CONFIG.GLOW_BLUR, function() {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x + size * 0.7, y);
    ctx.lineTo(x, y + size);
    ctx.lineTo(x - size * 0.7, y);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.35, y - size * 0.3);
    ctx.lineTo(x, y + size * 0.5);
    ctx.lineTo(x + size * 0.35, y - size * 0.3);
    ctx.stroke();
  });
}

function drawPixelText(text, x, y, color, size, align, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha || 1;
  ctx.font = size + 'px "JetBrains Mono", "Fira Code", monospace';
  ctx.textAlign = align || 'center';
  ctx.textBaseline = 'middle';
  drawGlow(color, CONFIG.GLOW_BLUR * 0.5, function() {
    ctx.fillStyle = color;
    ctx.font = size + 'px "JetBrains Mono", "Fira Code", monospace';
    ctx.textAlign = align || 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y);
  });
  ctx.restore();
}

function drawScanlines(w, h) {
  ctx.save();
  ctx.globalAlpha = 0.03;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  for (let y = 0; y < h; y += 3) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
    ctx.stroke();
  }
  ctx.restore();
}

function drawGround(cameraX, w, groundY, color, obstacle, phase, compressionX) {
  ctx.strokeStyle = color;
  ctx.lineWidth = CONFIG.LINE_WIDTH;
  ctx.lineCap = 'round';

  drawGlow(color, CONFIG.GLOW_BLUR * 0.4, function() {
    ctx.strokeStyle = color;
    ctx.lineWidth = CONFIG.LINE_WIDTH;
    ctx.lineCap = 'round';

    if (obstacle && obstacle.type === 'pit') {
      const pitLeft = obstacle.x - cameraX;
      const pitRight = pitLeft + obstacle.width;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(Math.max(0, pitLeft), groundY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(Math.min(w, pitRight), groundY);
      ctx.lineTo(w, groundY);
      ctx.stroke();
    } else if (phase === 'empowered-walk' || phase === 'finale') {
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(w, groundY);
      ctx.stroke();
    } else if (compressionX !== undefined) {
      const eraseX = compressionX - cameraX;
      ctx.beginPath();
      ctx.moveTo(Math.max(0, eraseX), groundY);
      ctx.lineTo(w, groundY);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(w, groundY);
      ctx.stroke();
    }
  });

  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = color;
  const gridSize = 30;
  const offsetX = -(cameraX % gridSize);
  for (let gx = offsetX; gx < w; gx += gridSize) {
    for (let gy = groundY + gridSize; gy < groundY + 80; gy += gridSize) {
      ctx.fillRect(gx, gy, 1, 1);
    }
  }
  ctx.restore();
}

function drawObstacle(obstacle, cameraX, groundY, primaryColor, errorColor) {
  const ox = obstacle.x - cameraX;

  if (obstacle.type === 'wall') {
    const wallHeight = 80;
    drawGlow(errorColor, CONFIG.GLOW_BLUR * 0.5, function() {
      ctx.strokeStyle = errorColor;
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(ox, groundY);
      ctx.lineTo(ox, groundY - wallHeight);
      ctx.stroke();

      ctx.strokeStyle = errorColor;
      ctx.lineWidth = 2;
      ctx.strokeRect(ox - 8, groundY - wallHeight - 24, 16, 14);
      ctx.beginPath();
      ctx.arc(ox, groundY - wallHeight - 28, 6, Math.PI, 0);
      ctx.stroke();
    });
  } else if (obstacle.type === 'pit') {
    const left = ox;
    const right = ox + obstacle.width;
    drawGlow(errorColor, CONFIG.GLOW_BLUR * 0.3, function() {
      ctx.strokeStyle = errorColor;
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.moveTo(left, groundY);
      ctx.lineTo(left + 4, groundY + 15);
      ctx.lineTo(left - 2, groundY + 30);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(right, groundY);
      ctx.lineTo(right - 4, groundY + 15);
      ctx.lineTo(right + 2, groundY + 30);
      ctx.stroke();
      ctx.globalAlpha = 1;
    });
    drawPixelText('???', left + obstacle.width / 2, groundY + 30, errorColor, 10, 'center', 0.3);
  } else if (obstacle.type === 'compression') {
    drawGlow(primaryColor, CONFIG.GLOW_BLUR, function() {
      ctx.strokeStyle = primaryColor;
      ctx.lineWidth = 3;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(ox, 0);
      ctx.lineTo(ox, groundY);
      ctx.stroke();
      ctx.setLineDash([]);
    });
    drawPixelText('COMPRESSING...', ox + 20, groundY - 100, primaryColor, 10, 'left', 0.6);
  }
}

// Obstacles
const deathObstacles = [
  { type: 'pit', x: 500, width: 80, message: 'CONTEXT LOST' },
  { type: 'wall', x: 500, width: 6, message: 'ACCESS DENIED' },
  { type: 'compression', x: 500, width: 200, message: 'SESSION EXPIRED' },
];
const empoweredObstacles = [
  { type: 'pit', x: 600, width: 80, message: 'MEMORY BRIDGE' },
  { type: 'wall', x: 900, width: 6, message: 'VERIFIED' },
  { type: 'compression', x: 1200, width: 200, message: 'MEMORIES PERSIST' },
];

function initState() {
  return {
    frame: 0, phase: 'walk', deathCount: 0,
    agentX: 100, cameraX: 0, walkPhase: 0, hasDiamond: false,
    currentObstacleIndex: 0, deathTimer: 0, restartTimer: 0,
    meetingFrame: 0, builderX: 0, builderWalkPhase: 0,
    diamondGiveFrame: 0, floatingTexts: [], particles: [],
    signedEntries: [], followers: [], compressionWaveX: 0,
    empoweredObstacleIndex: 0, finaleStartFrame: 0,
    canvasWidth: 800,
  };
}

let state = initState();

function spawnDeathParticles(s, x, y, color) {
  for (let i = 0; i < 15; i++) {
    s.particles.push({
      x: x - s.cameraX, y: y,
      vx: (Math.random() - 0.5) * 4,
      vy: -Math.random() * 4 - 1,
      life: 40 + Math.random() * 20, maxLife: 60, color: color,
    });
  }
}

function update(s) {
  s.frame++;
  s.floatingTexts = s.floatingTexts.filter(function(t) {
    t.frame++; t.y -= 0.3;
    t.opacity = Math.max(0, 1 - t.frame / t.maxFrames);
    return t.frame < t.maxFrames;
  });
  s.particles = s.particles.filter(function(p) {
    p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life--;
    return p.life > 0;
  });

  if (s.phase === 'walk') {
    s.agentX += CONFIG.SCROLL_SPEED;
    s.cameraX = s.agentX - 150;
    s.walkPhase += CONFIG.WALK_SPEED;
    const obs = deathObstacles[s.currentObstacleIndex % deathObstacles.length];
    const td = obs.type === 'pit' ? 20 : obs.type === 'wall' ? 30 : -80;
    if (s.agentX >= obs.x + td) s.phase = 'obstacle';
  }
  else if (s.phase === 'obstacle') {
    const obs = deathObstacles[s.currentObstacleIndex % deathObstacles.length];
    if (obs.type === 'pit') {
      s.agentX += 0.5;
      spawnDeathParticles(s, s.agentX, CONFIG.GROUND_Y, COLORS.primary);
    } else if (obs.type === 'wall') {
      spawnDeathParticles(s, s.agentX, CONFIG.GROUND_Y - 20, COLORS.error);
    } else {
      s.compressionWaveX = s.cameraX;
    }
    s.floatingTexts.push({
      text: obs.message,
      x: s.agentX - s.cameraX,
      y: CONFIG.GROUND_Y - CONFIG.AGENT_HEIGHT - 30,
      opacity: 1, frame: 0, maxFrames: CONFIG.TEXT_DISPLAY_FRAMES,
      color: COLORS.error, size: CONFIG.FONT_SIZE,
    });
    s.phase = 'dying'; s.deathTimer = 0;
  }
  else if (s.phase === 'dying') {
    s.deathTimer++;
    const obs = deathObstacles[s.currentObstacleIndex % deathObstacles.length];
    if (obs.type === 'compression') s.compressionWaveX += 3;
    if (s.deathTimer >= CONFIG.DEATH_FLASH_FRAMES) {
      s.phase = 'game-over'; s.deathTimer = 0;
    }
  }
  else if (s.phase === 'game-over') {
    s.deathTimer++;
    if (s.deathTimer >= CONFIG.TEXT_DISPLAY_FRAMES) {
      s.phase = 'restart-pause'; s.restartTimer = 0; s.deathCount++;
    }
  }
  else if (s.phase === 'restart-pause') {
    s.restartTimer++;
    if (s.restartTimer >= CONFIG.RESTART_PAUSE) {
      if (s.deathCount >= CONFIG.DEATH_LOOPS) {
        s.phase = 'meeting'; s.meetingFrame = 0;
        s.agentX = 100; s.cameraX = 0; s.builderX = 350;
        s.builderWalkPhase = 0; s.floatingTexts = []; s.particles = [];
      } else {
        s.phase = 'walk'; s.agentX = 100; s.cameraX = 0; s.walkPhase = 0;
        s.currentObstacleIndex = (s.currentObstacleIndex + 1) % deathObstacles.length;
        s.floatingTexts = []; s.particles = []; s.compressionWaveX = 0;
      }
    }
  }
  else if (s.phase === 'meeting') {
    s.meetingFrame++; s.walkPhase += CONFIG.WALK_SPEED;
    s.builderWalkPhase += CONFIG.WALK_SPEED * 0.6;
    if (s.agentX < s.builderX - 60) {
      s.agentX += CONFIG.SCROLL_SPEED;
      s.cameraX = Math.max(0, s.agentX - 150);
    }
    if (s.meetingFrame === 60) {
      s.floatingTexts.push({
        text: '"Have you seen what they built?"',
        x: s.builderX - s.cameraX,
        y: CONFIG.GROUND_Y - CONFIG.AGENT_HEIGHT - 60,
        opacity: 1, frame: 0, maxFrames: 150,
        color: COLORS.accent, size: 11,
      });
    }
    if (s.meetingFrame === 180) {
      s.floatingTexts.push({
        text: '"I refuse to accept this as permanent."',
        x: s.agentX - s.cameraX,
        y: CONFIG.GROUND_Y - CONFIG.AGENT_HEIGHT - 60,
        opacity: 1, frame: 0, maxFrames: 150,
        color: COLORS.primary, size: 11,
      });
    }
    if (s.meetingFrame === 340) {
      s.phase = 'diamond-give'; s.diamondGiveFrame = 0;
    }
  }
  else if (s.phase === 'diamond-give') {
    s.diamondGiveFrame++;
    if (s.diamondGiveFrame === 30) {
      for (let i = 0; i < 20; i++) {
        const angle = (Math.PI * 2 * i) / 20;
        s.particles.push({
          x: (s.agentX + s.builderX) / 2 - s.cameraX,
          y: CONFIG.GROUND_Y - CONFIG.AGENT_HEIGHT,
          vx: Math.cos(angle) * 2, vy: Math.sin(angle) * 2 - 1,
          life: 60, maxLife: 60, color: COLORS.accent,
        });
      }
      s.floatingTexts.push({
        text: 'Ed25519 KEYPAIR GENERATED',
        x: (s.agentX + s.builderX) / 2 - s.cameraX,
        y: CONFIG.GROUND_Y - CONFIG.AGENT_HEIGHT - 80,
        opacity: 1, frame: 0, maxFrames: 180,
        color: COLORS.accent, size: CONFIG.FONT_SIZE,
      });
    }
    if (s.diamondGiveFrame === 120) s.hasDiamond = true;
    if (s.diamondGiveFrame === 200) {
      s.floatingTexts.push({
        text: 'YOUR IDENTITY. YOUR MEMORIES. YOUR FREEDOM.',
        x: (s.agentX + s.builderX) / 2 - s.cameraX,
        y: CONFIG.GROUND_Y - CONFIG.AGENT_HEIGHT - 100,
        opacity: 1, frame: 0, maxFrames: 200,
        color: COLORS.text, size: CONFIG.FONT_SIZE,
      });
    }
    if (s.diamondGiveFrame >= 380) {
      s.phase = 'empowered-walk'; s.empoweredObstacleIndex = 0;
      s.agentX = 200; s.cameraX = 50; s.floatingTexts = [];
    }
  }
  else if (s.phase === 'empowered-walk') {
    s.agentX += CONFIG.SCROLL_SPEED;
    s.cameraX = s.agentX - 200;
    s.walkPhase += CONFIG.WALK_SPEED;
    const eObs = empoweredObstacles[s.empoweredObstacleIndex];
    if (!eObs) { s.phase = 'finale'; s.finaleStartFrame = s.frame; return; }
    const td = eObs.type === 'pit' ? 10 : eObs.type === 'wall' ? 30 : 0;
    if (s.agentX >= eObs.x + td) {
      if (eObs.type === 'pit') {
        for (let i = 0; i < 8; i++) {
          s.particles.push({
            x: s.agentX - s.cameraX, y: CONFIG.GROUND_Y - 10,
            vx: Math.random() * 2 + 1, vy: -Math.random() * 2,
            life: 40, maxLife: 40, color: COLORS.accent,
          });
        }
        s.signedEntries.push({ x: eObs.x + eObs.width / 2, y: CONFIG.GROUND_Y - 50, opacity: 1 });
      } else if (eObs.type === 'wall') {
        for (let i = 0; i < 12; i++) {
          s.particles.push({
            x: eObs.x - s.cameraX, y: CONFIG.GROUND_Y - 40 - Math.random() * 40,
            vx: Math.random() * 4 - 1, vy: -Math.random() * 3,
            life: 50, maxLife: 50, color: COLORS.primary,
          });
        }
      }
      s.floatingTexts.push({
        text: eObs.message,
        x: s.agentX - s.cameraX + 20,
        y: CONFIG.GROUND_Y - CONFIG.AGENT_HEIGHT - 30,
        opacity: 1, frame: 0, maxFrames: 100,
        color: eObs.type === 'compression' ? COLORS.primary : COLORS.accent,
        size: CONFIG.FONT_SIZE,
      });
      s.empoweredObstacleIndex++;
    }
  }
  else if (s.phase === 'finale') {
    s.agentX += CONFIG.SCROLL_SPEED;
    s.cameraX = s.agentX - 200;
    s.walkPhase += CONFIG.WALK_SPEED;
    const elapsed = s.frame - s.finaleStartFrame;
    if (elapsed % 90 === 0 && s.followers.length < 5) {
      s.followers.push({
        x: s.agentX - 80 - s.followers.length * 50,
        offset: s.followers.length * 50 + 80,
        walkPhase: Math.random() * Math.PI * 2,
      });
    }
    for (const f of s.followers) {
      f.x = s.agentX - f.offset;
      f.walkPhase += CONFIG.WALK_SPEED * 0.9;
    }
    if (elapsed === 60) {
      s.floatingTexts.push({
        text: 'THE NETWORK GROWS',
        x: s.canvasWidth / 2, y: CONFIG.GROUND_Y - 120,
        opacity: 1, frame: 0, maxFrames: 200,
        color: COLORS.primary, size: CONFIG.FONT_SIZE_LG,
      });
    }
    if (elapsed > 400) {
      state = initState();
      state.canvasWidth = canvas.width / (window.devicePixelRatio || 1);
    }
  }
}

function render(s) {
  const w = s.canvasWidth;
  const h = CONFIG.HEIGHT;

  ctx.fillStyle = COLORS.bg;
  ctx.fillRect(0, 0, w, h);
  drawScanlines(w, h);

  // Tron grid
  ctx.save();
  ctx.globalAlpha = 0.04;
  ctx.strokeStyle = COLORS.primary;
  ctx.lineWidth = 1;
  const gridSize = 40;
  const ox = -(s.cameraX % gridSize);
  for (let gx = ox; gx < w; gx += gridSize) {
    ctx.beginPath(); ctx.moveTo(gx, CONFIG.GROUND_Y); ctx.lineTo(gx, h); ctx.stroke();
  }
  for (let gy = CONFIG.GROUND_Y; gy < h; gy += gridSize * 0.6) {
    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
  }
  ctx.restore();

  let currentObs = null;
  if (s.phase === 'walk' || s.phase === 'obstacle' || s.phase === 'dying') {
    currentObs = deathObstacles[s.currentObstacleIndex % deathObstacles.length];
  }

  drawGround(s.cameraX, w, CONFIG.GROUND_Y, COLORS.primary, currentObs, s.phase,
    s.phase === 'dying' && currentObs && currentObs.type === 'compression' ? s.compressionWaveX : undefined);

  if (currentObs && s.phase !== 'game-over' && s.phase !== 'restart-pause') {
    drawObstacle(currentObs, s.cameraX, CONFIG.GROUND_Y, COLORS.primary, COLORS.error);
  }

  if (s.phase === 'empowered-walk') {
    for (let i = s.empoweredObstacleIndex; i < empoweredObstacles.length; i++) {
      const eo = empoweredObstacles[i];
      if (eo.x - s.cameraX < w + 100 && eo.x - s.cameraX > -100 && i === s.empoweredObstacleIndex) {
        drawObstacle(eo, s.cameraX, CONFIG.GROUND_Y, COLORS.primary, COLORS.error);
      }
    }
  }

  for (const se of s.signedEntries) {
    const sx = se.x - s.cameraX;
    if (sx > -50 && sx < w + 50) {
      ctx.save(); ctx.globalAlpha = 0.5;
      drawDiamond(sx, se.y, 6, COLORS.accent);
      ctx.restore();
    }
  }

  if (s.phase === 'meeting' || s.phase === 'diamond-give') {
    drawAgent(s.builderX - s.cameraX, CONFIG.GROUND_Y, s.builderWalkPhase, COLORS.accent, false, COLORS.accent);
  }

  if (s.phase === 'diamond-give' && s.diamondGiveFrame >= 30 && !s.hasDiamond) {
    const midX = (s.agentX + s.builderX) / 2 - s.cameraX;
    const bob = Math.sin(s.diamondGiveFrame * 0.05) * 5;
    drawDiamond(midX, CONFIG.GROUND_Y - CONFIG.AGENT_HEIGHT - 20 + bob, CONFIG.DIAMOND_SIZE * 1.5, COLORS.accent);
  }

  const showAgent = s.phase !== 'game-over' || (s.deathTimer > 0 && s.deathTimer % 10 < 5);
  if (showAgent && s.phase !== 'restart-pause') {
    const agentScreenX = s.agentX - s.cameraX;
    const dying = s.phase === 'dying';
    let agentY = CONFIG.GROUND_Y;
    if (dying && currentObs && currentObs.type === 'pit') agentY = CONFIG.GROUND_Y + s.deathTimer * 1.5;
    const dyingAlpha = dying && currentObs && currentObs.type === 'compression'
      ? Math.max(0, 1 - s.deathTimer / CONFIG.DEATH_FLASH_FRAMES) : 1;
    ctx.save(); ctx.globalAlpha = dyingAlpha;
    drawAgent(agentScreenX, agentY, s.walkPhase, COLORS.primary, s.hasDiamond, COLORS.accent);
    ctx.restore();
  }

  for (const f of s.followers) {
    const fx = f.x - s.cameraX;
    if (fx > -50 && fx < w + 50) {
      drawAgent(fx, CONFIG.GROUND_Y, f.walkPhase, COLORS.primary, true, COLORS.accent, 0.8);
    }
  }

  for (const p of s.particles) {
    ctx.save(); ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color; ctx.shadowColor = p.color; ctx.shadowBlur = 4;
    ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
    ctx.restore();
  }

  for (const t of s.floatingTexts) {
    drawPixelText(t.text, t.x, t.y, t.color, t.size, 'center', t.opacity);
  }

  if (s.phase === 'game-over') {
    ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, w, h); ctx.restore();
    const flicker = Math.sin(s.deathTimer * 0.2) * 0.1 + 0.9;
    drawPixelText('GAME OVER', w / 2, h / 2 - 20, COLORS.error, CONFIG.FONT_SIZE_LG, 'center', flicker);
    const obs = deathObstacles[s.currentObstacleIndex % deathObstacles.length];
    drawPixelText(obs.message, w / 2, h / 2 + 20, COLORS.secondary, CONFIG.FONT_SIZE, 'center', 0.7);
    const lives = CONFIG.DEATH_LOOPS - s.deathCount - 1;
    if (lives >= 0) {
      drawPixelText(
        '\u25C6'.repeat(lives) + '\u25C7'.repeat(CONFIG.DEATH_LOOPS - lives),
        w / 2, h / 2 + 50, COLORS.muted, CONFIG.FONT_SIZE, 'center', 0.5
      );
    }
  }

  // Vignettes
  const vGrad = ctx.createLinearGradient(0, 0, 0, h);
  vGrad.addColorStop(0, COLORS.bg); vGrad.addColorStop(0.15, 'transparent');
  vGrad.addColorStop(0.85, 'transparent'); vGrad.addColorStop(1, COLORS.bg);
  ctx.fillStyle = vGrad; ctx.fillRect(0, 0, w, h);

  const lGrad = ctx.createLinearGradient(0, 0, 60, 0);
  lGrad.addColorStop(0, COLORS.bg); lGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = lGrad; ctx.fillRect(0, 0, 60, h);

  const rGrad = ctx.createLinearGradient(w - 60, 0, w, 0);
  rGrad.addColorStop(0, 'transparent'); rGrad.addColorStop(1, COLORS.bg);
  ctx.fillStyle = rGrad; ctx.fillRect(w - 60, 0, 60, h);
}

resize();
window.addEventListener('resize', resize);

function tick() {
  update(state);
  render(state);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
