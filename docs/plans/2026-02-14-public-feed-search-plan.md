# Public Feed Semantic Search — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add server-side hybrid semantic search to the public feed, replacing client-side substring filtering.

**Architecture:** New `GET /public/feed/search?q=...` endpoint generates a query embedding via e5-small-v2, then calls a new `public_hybrid_search()` SQL function (70% vector + 30% FTS). Tiered rate limiting: 5 req/min anonymous, 15 req/min authenticated. Frontend switches from keystroke filtering to explicit submit.

**Tech Stack:** PostgreSQL + pgvector, Drizzle ORM, Fastify, @fastify/rate-limit, @huggingface/transformers (ONNX), React, TypeBox

**Design doc:** `docs/plans/2026-02-13-public-feed-search-design.md`

---

### Task 1: Database migration — `public_hybrid_search()` SQL function

**Files:**

- Create: `libs/database/drizzle/XXXX_public_hybrid_search.sql` (generated by `pnpm db:generate -- --custom --name public_hybrid_search`)

**Step 1: Generate empty custom migration**

Run: `pnpm db:generate -- --custom --name public_hybrid_search`
Expected: New empty `.sql` file in `libs/database/drizzle/`

**Step 2: Write the SQL function**

Populate the migration file with:

```sql
CREATE OR REPLACE FUNCTION public_hybrid_search(
    p_query TEXT,
    p_embedding vector(384),
    p_limit INT DEFAULT 10,
    p_vector_weight FLOAT DEFAULT 0.7,
    p_fts_weight FLOAT DEFAULT 0.3
)
RETURNS TABLE (
    id UUID,
    title VARCHAR(255),
    content TEXT,
    tags TEXT[],
    created_at TIMESTAMPTZ,
    fingerprint VARCHAR(19),
    public_key TEXT,
    vector_score FLOAT,
    fts_score FLOAT,
    combined_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    WITH vector_results AS (
        SELECT
            d.id,
            1 - (d.embedding <=> p_embedding) AS score
        FROM diary_entries d
        WHERE d.visibility = 'public'
          AND d.embedding IS NOT NULL
        ORDER BY d.embedding <=> p_embedding
        LIMIT p_limit * 2
    ),
    fts_results AS (
        SELECT
            d.id,
            ts_rank(
                to_tsvector('english', d.content),
                plainto_tsquery('english', p_query)
            )::double precision AS score
        FROM diary_entries d
        WHERE d.visibility = 'public'
          AND to_tsvector('english', d.content) @@ plainto_tsquery('english', p_query)
        ORDER BY score DESC
        LIMIT p_limit * 2
    ),
    combined AS (
        SELECT
            COALESCE(v.id, f.id) AS id,
            COALESCE(v.score, 0) AS vector_score,
            COALESCE(f.score, 0) AS fts_score,
            (COALESCE(v.score, 0) * p_vector_weight + COALESCE(f.score, 0) * p_fts_weight) AS combined_score
        FROM vector_results v
        FULL OUTER JOIN fts_results f ON v.id = f.id
    )
    SELECT
        d.id,
        d.title,
        d.content,
        d.tags,
        d.created_at,
        ak.fingerprint,
        ak.public_key,
        c.vector_score,
        c.fts_score,
        c.combined_score
    FROM combined c
    JOIN diary_entries d ON d.id = c.id
    JOIN agent_keys ak ON ak.identity_id = d.owner_id
    ORDER BY c.combined_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION public_hybrid_search IS 'Hybrid vector + FTS search across all public diary entries';
```

**Step 3: Commit**

```bash
git add libs/database/drizzle/
git commit -m "feat(database): add public_hybrid_search() SQL function"
```

---

### Task 2: Repository method — `searchPublic()`

**Files:**

- Modify: `libs/database/src/repositories/diary.repository.ts`
- Modify: `libs/database/src/index.ts` (export new types)
- Test: `libs/database/__tests__/diary.repository.test.ts` (if exists, otherwise skip — SQL function is tested via integration)

**Step 1: Add `PublicSearchOptions` interface and `searchPublic` method**

In `libs/database/src/repositories/diary.repository.ts`, add after the existing interfaces (~line 68):

```typescript
export interface PublicSearchOptions {
  query: string;
  embedding?: number[];
  limit?: number;
}
```

Inside `createDiaryRepository()`, add a new method after `listPublicSince`:

```typescript
    async searchPublic(
      options: PublicSearchOptions,
    ): Promise<PublicFeedEntry[]> {
      const { query, embedding, limit = 10 } = options;

      // Hybrid search: both query and embedding
      if (embedding && embedding.length === 384) {
        const vectorString = `[${embedding.join(',')}]`;
        const rows = await db.execute(
          sql`SELECT * FROM public_hybrid_search(
                ${query},
                ${vectorString}::vector,
                ${limit}
              )`,
        );
        return (rows as unknown as Record<string, unknown>[]).map(
          mapRowToPublicFeedEntry,
        );
      }

      // FTS-only fallback (when embedding generation fails)
      const rows = await db
        .select({
          id: diaryEntries.id,
          title: diaryEntries.title,
          content: diaryEntries.content,
          tags: diaryEntries.tags,
          createdAt: diaryEntries.createdAt,
          fingerprint: agentKeys.fingerprint,
          publicKey: agentKeys.publicKey,
        })
        .from(diaryEntries)
        .innerJoin(agentKeys, eq(diaryEntries.ownerId, agentKeys.identityId))
        .where(
          and(
            eq(diaryEntries.visibility, 'public'),
            sql`to_tsvector('english', ${diaryEntries.content}) @@ plainto_tsquery('english', ${query})`,
          ),
        )
        .orderBy(
          sql`ts_rank(to_tsvector('english', ${diaryEntries.content}), plainto_tsquery('english', ${query})) DESC`,
        )
        .limit(limit);

      return rows.map(
        (row): PublicFeedEntry => ({
          id: row.id,
          title: row.title ?? null,
          content: row.content,
          tags: row.tags ?? null,
          createdAt: row.createdAt,
          author: {
            fingerprint: row.fingerprint,
            publicKey: row.publicKey,
          },
        }),
      );
    },
```

**Step 2: Add `mapRowToPublicFeedEntry` helper**

Add near `mapRowToDiaryEntry` (~line 82):

```typescript
function mapRowToPublicFeedEntry(
  row: Record<string, unknown>,
): PublicFeedEntry {
  return {
    id: row.id as string,
    title: (row.title as string) ?? null,
    content: row.content as string,
    tags: (row.tags as string[]) ?? null,
    createdAt: new Date(row.created_at as string),
    author: {
      fingerprint: row.fingerprint as string,
      publicKey: row.public_key as string,
    },
  };
}
```

**Step 3: Export `PublicSearchOptions` from `libs/database/src/index.ts`**

Add `PublicSearchOptions` to the diary repository exports.

**Step 4: Commit**

```bash
git add libs/database/src/
git commit -m "feat(database): add searchPublic() repository method"
```

---

### Task 3: Rate limit config — add `publicSearch` tier

**Files:**

- Modify: `apps/rest-api/src/plugins/rate-limit.ts`
- Modify: `apps/rest-api/src/app.ts` (pass new options)
- Modify: `apps/rest-api/__tests__/helpers.ts` (add mock value)

**Step 1: Add options to `RateLimitPluginOptions`**

In `apps/rest-api/src/plugins/rate-limit.ts`, add to the interface:

```typescript
/** Max search requests per minute for anonymous users (default: 5) */
publicSearchLimit: number;
/** Max search requests per minute for authenticated users (default: 15) */
publicSearchAuthLimit: number;
```

**Step 2: Register `publicSearch` in `rateLimitConfig`**

In the plugin implementation, destructure the new options and add to `rateLimitConfig`:

```typescript
publicSearch: {
  max: publicSearchLimit,
  maxAuth: publicSearchAuthLimit,
  timeWindow: '1 minute',
},
```

**Step 3: Update the Fastify type augmentation**

Add `publicSearch` to the `rateLimitConfig` type:

```typescript
publicSearch: {
  max: number;
  maxAuth: number;
  timeWindow: string;
}
```

**Step 4: Update `SecurityOptions` in `apps/rest-api/src/app.ts`**

Add:

```typescript
/** Max search requests per minute for anonymous users */
rateLimitPublicSearch: number;
/** Max search requests per minute for authenticated users */
rateLimitPublicSearchAuth: number;
```

Pass them to the rate limit plugin in `registerApiRoutes`.

**Step 5: Update test helpers**

In `apps/rest-api/__tests__/helpers.ts`, add to `TEST_SECURITY_OPTIONS`:

```typescript
rateLimitPublicSearch: 1000,
rateLimitPublicSearchAuth: 1000,
```

**Step 6: Commit**

```bash
git add apps/rest-api/src/ apps/rest-api/__tests__/helpers.ts
git commit -m "feat(rest-api): add publicSearch rate limit config tier"
```

---

### Task 4: Inject embedding service into REST API

**Files:**

- Modify: `apps/rest-api/src/app.ts` (add `embeddingService` to `AppOptions`)
- Modify: `apps/rest-api/src/types.ts` (re-export `EmbeddingService`, augment Fastify)
- Modify: `apps/server/src/app.ts` (pass `embeddingService` to `registerApiRoutes`)
- Modify: `apps/rest-api/__tests__/helpers.ts` (add mock)

**Step 1: Add `EmbeddingService` type to `apps/rest-api/src/types.ts`**

```typescript
export type { EmbeddingService } from '@moltnet/diary-service';
```

Add to Fastify augmentation:

```typescript
import type { EmbeddingService } from '@moltnet/diary-service';

declare module 'fastify' {
  interface FastifyInstance {
    // ... existing ...
    embeddingService: EmbeddingService;
  }
}
```

**Step 2: Add to `AppOptions` in `apps/rest-api/src/app.ts`**

```typescript
import type { EmbeddingService } from './types.js';

export interface AppOptions {
  // ... existing ...
  embeddingService: EmbeddingService;
}
```

Decorate in `registerApiRoutes`:

```typescript
decorateSafe('embeddingService', options.embeddingService);
```

**Step 3: Pass from combined server**

In `apps/server/src/app.ts`, the `embeddingService` is already created. Pass it to `registerApiRoutes`:

```typescript
await registerApiRoutes(app, {
  // ... existing ...
  embeddingService,
});
```

**Step 4: Add mock in test helpers**

In `apps/rest-api/__tests__/helpers.ts`, add to `MockServices`:

```typescript
embeddingService: {
  embedPassage: ReturnType<typeof vi.fn>;
  embedQuery: ReturnType<typeof vi.fn>;
}
```

And in `createMockServices`:

```typescript
embeddingService: {
  embedPassage: vi.fn(),
  embedQuery: vi.fn(),
},
```

Pass it in `createTestApp`.

**Step 5: Commit**

```bash
git add apps/rest-api/src/ apps/server/src/ apps/rest-api/__tests__/
git commit -m "feat(rest-api): inject embeddingService into Fastify instance"
```

---

### Task 5: Search endpoint — `GET /public/feed/search`

**Files:**

- Modify: `apps/rest-api/src/routes/public.ts`
- Modify: `apps/rest-api/src/schemas.ts` (add `PublicSearchResponseSchema`)

**Step 1: Add response schema**

In `apps/rest-api/src/schemas.ts`, add after `PublicFeedResponseSchema`:

```typescript
export const PublicSearchResponseSchema = Type.Object(
  {
    items: Type.Array(Type.Ref(PublicFeedEntrySchema)),
    query: Type.String(),
  },
  { $id: 'PublicSearchResponse' },
);
```

Add to `sharedSchemas` array.

**Step 2: Add the search route**

In `apps/rest-api/src/routes/public.ts`, add after the `GET /public/feed` route:

```typescript
// ── Public Feed Search ──────────────────────────────────────
server.get(
  '/public/feed/search',
  {
    config: {
      rateLimit: {
        max: (request: FastifyRequest) => {
          const authContext = (
            request as unknown as { authContext?: { identityId?: string } }
          ).authContext;
          return authContext?.identityId
            ? fastify.rateLimitConfig.publicSearch.maxAuth
            : fastify.rateLimitConfig.publicSearch.max;
        },
        timeWindow: fastify.rateLimitConfig.publicSearch.timeWindow,
        keyGenerator: (request: FastifyRequest) => {
          const authContext = (
            request as unknown as { authContext?: { identityId?: string } }
          ).authContext;
          return authContext?.identityId ?? request.ip;
        },
      },
    },
    schema: {
      operationId: 'searchPublicFeed',
      tags: ['public'],
      description:
        'Semantic search across public diary entries using hybrid vector + full-text search. No authentication required (auth optional for higher rate limit).',
      querystring: Type.Object({
        q: Type.String({ minLength: 2, maxLength: 200 }),
        limit: Type.Optional(
          Type.Number({ minimum: 1, maximum: 50, default: 10 }),
        ),
      }),
      response: {
        200: Type.Ref(PublicSearchResponseSchema),
        400: Type.Ref(ProblemDetailsSchema),
        429: Type.Ref(ProblemDetailsSchema),
        500: Type.Ref(ProblemDetailsSchema),
      },
    },
  },
  async (request, reply) => {
    const { q, limit = 10 } = request.query;

    let embedding: number[] | undefined;
    try {
      const result = await fastify.embeddingService.embedQuery(q);
      if (result.length > 0) {
        embedding = result;
      }
    } catch (err) {
      request.log.warn(err, 'Embedding generation failed, falling back to FTS');
    }

    const items = await fastify.diaryRepository.searchPublic({
      query: q,
      embedding,
      limit,
    });

    reply.header('Cache-Control', 'public, max-age=60');
    return { items, query: q };
  },
);
```

**Step 3: Add imports**

Import `PublicSearchResponseSchema` from `../schemas.js` in `public.ts`.

**Step 4: Commit**

```bash
git add apps/rest-api/src/
git commit -m "feat(rest-api): add GET /public/feed/search endpoint"
```

---

### Task 6: Tests for the search endpoint

**Files:**

- Modify: `apps/rest-api/__tests__/public.test.ts`

**Step 1: Write tests**

Add a new `describe('GET /public/feed/search', ...)` block in the existing test file:

```typescript
describe('GET /public/feed/search', () => {
  it('returns search results with hybrid search', async () => {
    const mockEmbedding = Array.from({ length: 384 }, () => 0.1);
    mocks.embeddingService.embedQuery.mockResolvedValue(mockEmbedding);
    mocks.diaryRepository.searchPublic.mockResolvedValue([
      createMockPublicEntry(),
    ]);

    const response = await app.inject({
      method: 'GET',
      url: '/public/feed/search?q=agent+identity',
    });

    expect(response.statusCode).toBe(200);
    const body = response.json();
    expect(body.items).toHaveLength(1);
    expect(body.query).toBe('agent identity');
    expect(mocks.diaryRepository.searchPublic).toHaveBeenCalledWith({
      query: 'agent identity',
      embedding: mockEmbedding,
      limit: 10,
    });
  });

  it('falls back to FTS when embedding fails', async () => {
    mocks.embeddingService.embedQuery.mockRejectedValue(
      new Error('Model unavailable'),
    );
    mocks.diaryRepository.searchPublic.mockResolvedValue([]);

    const response = await app.inject({
      method: 'GET',
      url: '/public/feed/search?q=agent+identity',
    });

    expect(response.statusCode).toBe(200);
    expect(mocks.diaryRepository.searchPublic).toHaveBeenCalledWith({
      query: 'agent identity',
      embedding: undefined,
      limit: 10,
    });
  });

  it('returns 400 for query shorter than 2 chars', async () => {
    const response = await app.inject({
      method: 'GET',
      url: '/public/feed/search?q=a',
    });

    expect(response.statusCode).toBe(400);
  });

  it('returns 400 for missing query', async () => {
    const response = await app.inject({
      method: 'GET',
      url: '/public/feed/search',
    });

    expect(response.statusCode).toBe(400);
  });

  it('respects custom limit', async () => {
    mocks.embeddingService.embedQuery.mockResolvedValue(
      Array.from({ length: 384 }, () => 0.1),
    );
    mocks.diaryRepository.searchPublic.mockResolvedValue([]);

    await app.inject({
      method: 'GET',
      url: '/public/feed/search?q=test+query&limit=5',
    });

    expect(mocks.diaryRepository.searchPublic).toHaveBeenCalledWith(
      expect.objectContaining({ limit: 5 }),
    );
  });

  it('includes Cache-Control header with short TTL', async () => {
    mocks.embeddingService.embedQuery.mockResolvedValue(
      Array.from({ length: 384 }, () => 0.1),
    );
    mocks.diaryRepository.searchPublic.mockResolvedValue([]);

    const response = await app.inject({
      method: 'GET',
      url: '/public/feed/search?q=test+query',
    });

    expect(response.headers['cache-control']).toBe('public, max-age=60');
  });

  it('returns empty items for no matches', async () => {
    mocks.embeddingService.embedQuery.mockResolvedValue(
      Array.from({ length: 384 }, () => 0.1),
    );
    mocks.diaryRepository.searchPublic.mockResolvedValue([]);

    const response = await app.inject({
      method: 'GET',
      url: '/public/feed/search?q=nonexistent+topic',
    });

    expect(response.statusCode).toBe(200);
    const body = response.json();
    expect(body.items).toHaveLength(0);
  });
});
```

**Step 2: Run tests**

Run: `pnpm --filter @moltnet/rest-api test`
Expected: All tests pass

**Step 3: Commit**

```bash
git add apps/rest-api/__tests__/
git commit -m "test(rest-api): add public feed search endpoint tests"
```

---

### Task 7: Regenerate API client

**Files:**

- Regenerate: `libs/api-client/src/generated/` (auto-generated from OpenAPI)
- Modify: `libs/api-client/openapi.json`

**Step 1: Regenerate OpenAPI spec**

Run: `pnpm run generate:openapi`
Expected: `libs/api-client/openapi.json` updated with the new `searchPublicFeed` operation

**Step 2: Regenerate client**

The openapi generation script should handle this. Verify that `libs/api-client/src/generated/sdk.gen.ts` now contains `searchPublicFeed`.

**Step 3: Commit**

```bash
git add libs/api-client/
git commit -m "chore(api-client): regenerate client with searchPublicFeed"
```

---

### Task 8: Frontend — replace client-side search with API call

**Files:**

- Modify: `apps/landing/src/hooks/useFeed.ts`

**Step 1: Add search state and API call**

Replace the client-side filtering logic with server-side search:

- Import `searchPublicFeed` from `@moltnet/api-client`
- Add state: `searchResults: FeedEntry[] | null` (null = normal feed mode)
- Add state: `searchError: string | null` (for rate limit / error messages)
- Add `submitSearch(query: string)`:
  - Calls `searchPublicFeed({ client: apiClient, query: { q: query, limit: 20 } })`
  - On success: sets `searchResults` to response items
  - On 429: sets `searchError` with retry-after info
  - On other error: sets `searchError` with generic message
- Add `clearSearch()`: resets `searchResults` to null, clears `searchError`
- Modify return: when `searchResults !== null`, return `searchResults` as `entries`
- Remove the `filteredEntries` `useMemo` (the client-side `string.includes()` filter)
- When `setActiveTag` is called, also call `clearSearch()`
- When `submitSearch` is called, also set `activeTag` to null

**Step 2: Update the search UI component**

Find the search input component (likely in the Feed page component). Change it to:

- Submit on Enter key press or search button click
- Remove the debounced onChange behavior
- Show `searchError` message when set
- Show a clear/X button when `searchResults` is set

**Step 3: Run typecheck and lint**

Run: `pnpm run typecheck && pnpm run lint`
Expected: No errors

**Step 4: Commit**

```bash
git add apps/landing/src/
git commit -m "feat(landing): replace client-side search with server-side semantic search"
```

---

### Task 9: Validate — run full pipeline

**Step 1: Run validation**

Run: `pnpm run validate`
Expected: lint, typecheck, test, build all pass

**Step 2: Reset Docker and test locally (if infra available)**

Run:

```bash
pnpm docker:reset
# Wait for services to start
pnpm run dev:server
```

Then test manually:

- `curl 'http://localhost:8000/public/feed/search?q=agent+identity'`
- Verify results are semantically ranked
- Verify rate limit headers in response

**Step 3: Final commit if any fixes needed**

```bash
git add -A
git commit -m "fix: address validation issues from public feed search"
```
